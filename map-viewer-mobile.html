<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- PWA meta tags for full screen -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Ocean Currents - Mobile</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Favicon for browser tab -->
  <link rel="icon" type="image/svg+xml" href="app-icon.svg">
  
  <!-- Apple Touch Icon (must be PNG for iOS) -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  
  <!-- Theme color for browser chrome -->
  <meta name="theme-color" content="#0077be">
  
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body, .app-wrapper {
      position: fixed;
      inset: 0;
      width: 100%;
      /* Dynamic viewport first, JS fallback second */
      height: 100dvh;
      height: var(--vhpx, 100vh);
      overflow: hidden;
      /* Prevent text selection and touch callouts */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    html {
      height: 100%;
      /* This is critical for iOS PWA full screen */
      height: -webkit-fill-available;
    }
    
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      /* Prevent bounce scrolling on iOS */
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* App wrapper fills viewport exactly */
    .app-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      /* Use full available height */
      height: 100vh;
      height: -webkit-fill-available;
      overflow: hidden;
      /* Prevent text selection and touch callouts */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    #map {
      position: fixed;
      left: 0;
      right: 0;
      width: 100%;
      /* Simple positioning - let the container handle safe areas */
      top: calc(28px + env(safe-area-inset-top, 0px));
      /* Bottom should just be the height of the slider container */
      bottom: calc(46px + env(safe-area-inset-bottom, 0px));
    }
    
    /* Top header with time display */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 28px;
      /* Support safe area for notch */
      padding-top: env(safe-area-inset-top, 0px);
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding-left: 12px;
      padding-right: 210px; /* Make room for tide chart */
      z-index: 2;
    }
    
    .time-display {
      font-size: 13px;
      color: #222;
      text-align: left;
      font-weight: 500;
    }
    
    .model-time {
      color: #666;
      font-weight: normal;
    }
    
    /* Bottom slider control */
    .slider-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      /* Total height includes the control height plus safe area */
      min-height: 42px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 -1px 3px rgba(0,0,0,0.12);
      padding: 4px 45px 0 45px;
      /* Only add bottom padding for safe area, not extra height */
      padding-bottom: env(safe-area-inset-bottom, 0px);
      z-index: 2;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Hour adjustment buttons */
    .hour-btn {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 32px;
      border-radius: 16px;
      background: #0066cc;
      color: white;
      border: none;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.2s;
      z-index: 3;
    }
    
    .hour-btn:active {
      background: #0052a3;
    }
    
    .hour-btn.prev {
      left: 8px;
    }
    
    .hour-btn.next {
      right: 8px;
    }
    
    .slider-label {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #666;
      text-align: center;
      white-space: nowrap;
      z-index: 3;
      background: rgba(255, 255, 255, 0.8);
      padding: 0 4px;
      border-radius: 2px;
    }
    
    .version-label {
      position: absolute;
      top: 2px;
      right: 48px; /* Position inside the next button */
      font-size: 9px;
      color: #999;
      z-index: 3;
      background: rgba(255, 255, 255, 0.9);
      padding: 0 4px;
      border-radius: 2px;
    }
    
    .time-slider {
      width: 100%;
      height: 35px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      outline: none;
    }
    
    .time-slider::-webkit-slider-track {
      width: 100%;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
    }
    
    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #0066cc;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    
    .time-slider::-moz-range-track {
      width: 100%;
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
    }
    
    .time-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      background: #0066cc;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    
    /* Loading indicator */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 10;
      font-size: 14px;
      color: #666;
    }
    
    .loading.hidden {
      display: none;
    }
    
    /* Current magnitude marker */
    .magnitude-marker {
      position: absolute;
      pointer-events: none;
      z-index: 5;
      transform: translate(-50%, -50%);
    }
    
    .magnitude-cross {
      position: absolute;
      width: 20px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .magnitude-cross::before,
    .magnitude-cross::after {
      content: '';
      position: absolute;
      background: #ff0000;
    }
    
    .magnitude-cross::before {
      width: 2px;
      height: 20px;
      left: 9px;
      top: 0;
    }
    
    .magnitude-cross::after {
      width: 20px;
      height: 2px;
      left: 0;
      top: 9px;
    }
    
    .magnitude-value {
      position: absolute;
      top: -8px;
      left: 15px;
      color: #ff0000;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 
        -1px -1px 0 #fff,
        1px -1px 0 #fff,
        -1px 1px 0 #fff,
        1px 1px 0 #fff,
        0 0 2px #fff;
      white-space: nowrap;
    }
    
    /* Tide chart */
    .tide-chart {
      position: fixed;
      top: 0;
      right: 0;
      width: 200px;
      height: 100px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 0 0 0 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      padding: 4px;
      z-index: 3;
      /* Account for safe area */
      padding-top: calc(4px + env(safe-area-inset-top, 0px));
    }
    
    .tide-chart-title {
      font-size: 10px;
      font-weight: 600;
      color: #333;
      margin-bottom: 2px;
    }
    
    .tide-chart-canvas {
      width: 100%;
      height: 80px;
      position: relative;
    }
    
    .tide-chart-svg {
      width: 100%;
      height: 100%;
    }
    
    .tide-current-line {
      stroke: #ff0000;
      stroke-width: 1.5;
      stroke-dasharray: 2,2;
      opacity: 0.7;
    }
    
    .tide-curve {
      fill: none;
      stroke: #0077be;
      stroke-width: 2;
    }
    
    .tide-area {
      fill: #0077be;
      opacity: 0.15;
    }
    
    .tide-label {
      font-size: 9px;
      fill: #666;
    }
    
    .tide-loading {
      font-size: 10px;
      color: #999;
      text-align: center;
      padding-top: 25px;
    }
    
    .tide-error {
      font-size: 10px;
      color: #cc0000;
      text-align: center;
      padding-top: 20px;
    }
    
    /* Hide on very small screens */
    @media (max-width: 360px) {
      .tide-chart {
        display: none;
      }
    }
    
    /* iOS PWA standalone mode specific fixes */
    @media (display-mode: standalone) {
      /* Ensure we use full height in standalone mode */
      html, body, .app-wrapper { height: 100dvh; }
    }
      
      .app-wrapper {
        height: 100vh;
        height: -webkit-fill-available;
      }
    }
    
  </style>
</head>
<body>
  <div class="app-wrapper">
    <div class="header">
      <div class="time-display" id="time-display">
        <span id="forecast-time">--</span>
      </div>
    </div>
    
    <div id="map"></div>
    
    <!-- Tide chart -->
    <div class="tide-chart" id="tide-chart">
      <div class="tide-chart-title">Seattle Tides</div>
      <div class="tide-chart-canvas" id="tide-canvas">
        <div class="tide-loading">Loading tides...</div>
      </div>
    </div>
    
    <div class="slider-container">
      <button class="hour-btn prev" id="hour-prev" aria-label="Previous hour">−1</button>
      <div class="slider-label" id="slider-label">Drag to change time</div>
      <div class="version-label" id="version-label"></div>
      <input type="range" class="time-slider" id="time-slider" min="0" max="72" value="0" step="1">
      <button class="hour-btn next" id="hour-next" aria-label="Next hour">+1</button>
    </div>
    
    <div class="loading" id="loading">Searching for model data...</div>
    
    <!-- Magnitude marker (hidden by default) -->
    <div class="magnitude-marker" id="magnitude-marker" style="display: none;">
      <div class="magnitude-cross"></div>
      <div class="magnitude-value" id="magnitude-value">0.0</div>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
    // Register service worker for offline support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js')
        .then(reg => console.log('Service Worker registered'))
        .catch(err => console.warn('Service Worker registration failed:', err));
    }
    
    // Simple production logging - errors only by default
    const IS_DEBUG = new URLSearchParams(location.search).has('debug');
    
    const logger = {
      error: console.error,
      warn: IS_DEBUG ? console.warn : () => {},
      info: IS_DEBUG ? console.info : () => {},
      debug: IS_DEBUG ? console.log : () => {},
    };
    
    // ========== CONFIGURATION ==========
    const CONFIG = {
      APP_VERSION: 'v1.3.3', // Attempting PWA Fix.
      PROXY_HOST: 'https://ocean-currents-proxy.violapaul.workers.dev',
      CENTER: [-122.3321, 47.6062], // Seattle
      ZOOM: 10,
      SSCOFS_CYCLES: [0, 3, 9, 15, 21],
      TIDE_STATION_ID: '9447130', // Seattle
      TILE_MIN_SIZE: 5000, // Minimum tile size in bytes to be considered valid
      MAX_FORECAST_HOURS: 72,
    };
    
    const PROXY_BASE = `${CONFIG.PROXY_HOST}/tiles/eis-live`;
    
    // ========== APPLICATION STATE ==========
    const state = {
      currentModelInfo: null,
      isUpdating: false,
      modelAvailability: [],
      magnitudeMarker: null,
      tideData: null,
      currentDisplayTime: null,
      isOffline: false,
    };
    
    // ========== MODEL FUNCTIONS ==========
    
    function getLatestCycle(utcDate) {
      const date = new Date(utcDate);
      const hour = date.getUTCHours();
      
      for (let i = CONFIG.SSCOFS_CYCLES.length - 1; i >= 0; i--) {
        if (hour >= CONFIG.SSCOFS_CYCLES[i]) {
          return {
            date: new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate())),
            cycle: CONFIG.SSCOFS_CYCLES[i]
          };
        }
      }
      
      const prevDate = new Date(date);
      prevDate.setUTCDate(prevDate.getUTCDate() - 1);
      return {
        date: new Date(Date.UTC(prevDate.getUTCFullYear(), prevDate.getUTCMonth(), prevDate.getUTCDate())),
        cycle: CONFIG.SSCOFS_CYCLES[CONFIG.SSCOFS_CYCLES.length - 1]
      };
    }
    
    function calculateForecastHour(cycleDate, cycleHour, targetDate) {
      const cycleStart = new Date(cycleDate);
      cycleStart.setUTCHours(cycleHour, 0, 0, 0);
      const hoursDiff = (targetDate - cycleStart) / (1000 * 60 * 60);
      return Math.max(0, Math.min(CONFIG.MAX_FORECAST_HOURS, Math.round(hoursDiff)));
    }
    
    // ========== UTILITY FUNCTIONS ==========
    
    function toIsoUTC(d) {
      const pad = (n) => String(n).padStart(2, "0");
      return d.getUTCFullYear() + "-" + 
             pad(d.getUTCMonth()+1) + "-" + 
             pad(d.getUTCDate()) + "T" + 
             pad(d.getUTCHours()) + ":00:00Z";
    }
    
    // ========== TIDE FUNCTIONS ==========
    
    // Cache tide data in localStorage with expiration
    function getTideCacheKey(date) {
      const d = new Date(date);
      return `tide_${CONFIG.TIDE_STATION_ID}_${d.getFullYear()}_${d.getMonth()}_${d.getDate()}`;
    }
    
    function getCachedTideData(date) {
      try {
        const key = getTideCacheKey(date);
        const cached = localStorage.getItem(key);
        if (cached) {
          const data = JSON.parse(cached);
          // Check if cache is less than 24 hours old
          if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
            // Convert string dates back to Date objects
            data.tides = data.tides.map(t => ({
              time: new Date(t.time),
              height: t.height
            }));
            logger.debug('Using cached tide data');
            return data.tides;
          }
        }
      } catch (e) {
        logger.warn('Error reading tide cache:', e);
      }
      return null;
    }
    
    function cacheTideData(date, tides) {
      try {
        const key = getTideCacheKey(date);
        localStorage.setItem(key, JSON.stringify({
          timestamp: Date.now(),
          tides: tides
        }));
        
        // Clean up old cache entries (keep only last 7 days)
        const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000);
        const keys = Object.keys(localStorage);
        keys.forEach(k => {
          if (k.startsWith('tide_')) {
            try {
              const data = JSON.parse(localStorage.getItem(k));
              if (data.timestamp < cutoff) {
                localStorage.removeItem(k);
              }
            } catch (e) {
              // Invalid entry, remove it
              localStorage.removeItem(k);
            }
          }
        });
      } catch (e) {
        logger.warn('Error caching tide data:', e);
      }
    }
    
    async function fetchTideData(displayTime) {
      // Check cache first
      const cached = getCachedTideData(displayTime);
      if (cached) {
        return cached;
      }
      
      // Get start and end of the current day in local time
      const localDate = new Date(displayTime);
      const dayStart = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), 0, 0, 0);
      const dayEnd = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate() + 1, 0, 0, 0); // Midnight of next day
      
      // Fetch data for the full day plus some buffer for interpolation
      // This ensures we always have complete data for the entire day
      const startTime = dayStart;
      const endTime = dayEnd;
      
      // Format dates for NOAA API (YYYYMMDD HH:MM)
      const formatNOAADate = (d) => {
        const pad = (n) => String(n).padStart(2, "0");
        return d.getFullYear() + 
               pad(d.getMonth()+1) + 
               pad(d.getDate()) + ' ' +
               pad(d.getHours()) + ':' +
               pad(d.getMinutes());
      };
      
      // NOAA CO-OPS API for tide predictions
      const noaaUrl = 'https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?' +
        `begin_date=${formatNOAADate(startTime)}&` +
        `end_date=${formatNOAADate(endTime)}&` +
        `station=${CONFIG.TIDE_STATION_ID}&` +
        `product=predictions&` +
        `datum=MLLW&` +
        `time_zone=lst_ldt&` +
        `units=english&` +
        `interval=6&` + // 6-minute intervals for smooth curve
        `format=json`;
      
      // Always use proxy - NOAA doesn't provide CORS headers either
      const url = `${CONFIG.PROXY_HOST}/noaa/tides?${noaaUrl.split('?')[1]}`;
      
      logger.debug('🌊 Fetching tide data:', url);
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.predictions && data.predictions.length > 0) {
          // Convert to simpler format with timestamps
          const tides = data.predictions.map(p => ({
            time: new Date(p.t.replace(' ', 'T')),
            height: parseFloat(p.v)
          }));
          
          logger.info(`🌊 Loaded ${tides.length} tide points`);
          // Cache the data
          cacheTideData(displayTime, tides);
          return tides;
        }
      } catch (error) {
        logger.error('❌ Error fetching tide data:', error);
        return null;
      }
    }
    
    function drawTideChart(tides, currentTime) {
      const canvas = document.getElementById('tide-canvas');
      
      if (!tides || tides.length === 0) {
        canvas.innerHTML = '<div class="tide-error">No tide data</div>';
        return;
      }
      
      // Get start and end of current day in local time
      const localDate = new Date(currentTime);
      const dayStart = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), 0, 0, 0);
      const dayEnd = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate() + 1, 0, 0, 0); // Midnight of next day
      
      // Filter tides to current day
      const windowTides = tides.filter(t => 
        t.time >= dayStart && t.time <= dayEnd
      );
      
      if (windowTides.length === 0) {
        canvas.innerHTML = '<div class="tide-error">No data for this day</div>';
        return;
      }
      
      // Calculate position of current time indicator (0-1 range)
      const dayDuration = dayEnd - dayStart;
      const currentOffset = currentTime - dayStart;
      const currentPosition = Math.max(0, Math.min(1, currentOffset / dayDuration));
      
      // Find min/max for scaling
      const heights = windowTides.map(t => t.height);
      const minHeight = Math.min(...heights);
      const maxHeight = Math.max(...heights);
      const heightRange = maxHeight - minHeight;
      
      // SVG dimensions
      const width = 192; // Account for padding
      const height = 80;
      const margin = { top: 3, right: 3, bottom: 12, left: 3 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      
      // Create SVG
      const svg = `
        <svg class="tide-chart-svg" viewBox="0 0 ${width} ${height}">
          <g transform="translate(${margin.left},${margin.top})">
            <!-- Grid lines -->
            <line x1="0" y1="${chartHeight/2}" x2="${chartWidth}" y2="${chartHeight/2}" 
                  stroke="#e0e0e0" stroke-width="0.5"/>
            
            <!-- Tide curve area -->
            <path class="tide-area" d="${
              'M ' + windowTides.map((t, i) => {
                const x = (i / (windowTides.length - 1)) * chartWidth;
                const y = chartHeight - ((t.height - minHeight) / heightRange) * chartHeight;
                return `${x},${y}`;
              }).join(' L ') + 
              ` L ${chartWidth},${chartHeight} L 0,${chartHeight} Z`
            }"/>
            
            <!-- Tide curve line -->
            <path class="tide-curve" d="${
              'M ' + windowTides.map((t, i) => {
                const x = (i / (windowTides.length - 1)) * chartWidth;
                const y = chartHeight - ((t.height - minHeight) / heightRange) * chartHeight;
                return `${x},${y}`;
              }).join(' L ')
            }"/>
            
            <!-- Current time indicator -->
            <line class="tide-current-line" 
                  x1="${chartWidth * currentPosition}" y1="0" 
                  x2="${chartWidth * currentPosition}" y2="${chartHeight}"/>
            
            <!-- Labels -->
            <text x="2" y="${chartHeight + 12}" class="tide-label">12am</text>
            <text x="${chartWidth/2}" y="${chartHeight + 12}" class="tide-label" text-anchor="middle">12pm</text>
            <text x="${chartWidth - 2}" y="${chartHeight + 12}" class="tide-label" text-anchor="end">12am</text>
            
            <!-- Height labels -->
            <text x="2" y="10" class="tide-label">${maxHeight.toFixed(1)}ft</text>
            <text x="2" y="${chartHeight}" class="tide-label">${minHeight.toFixed(1)}ft</text>
          </g>
        </svg>
      `;
      
      canvas.innerHTML = svg;
      
      // Find the tide height at current time by interpolation
      let currentHeight = 0;
      for (let i = 0; i < windowTides.length - 1; i++) {
        if (currentTime >= windowTides[i].time && currentTime <= windowTides[i + 1].time) {
          // Linear interpolation between two points
          const t1 = windowTides[i].time.getTime();
          const t2 = windowTides[i + 1].time.getTime();
          const h1 = windowTides[i].height;
          const h2 = windowTides[i + 1].height;
          const ratio = (currentTime.getTime() - t1) / (t2 - t1);
          currentHeight = h1 + (h2 - h1) * ratio;
          break;
        }
      }
      
      // Update title with current tide height
      document.querySelector('.tide-chart-title').textContent = 
        `Seattle - ${currentHeight.toFixed(1)}ft`;
    }
    
    async function updateTideChart(displayTime) {
      state.currentDisplayTime = displayTime;
      
      // Get the day boundaries for the display time
      const localDate = new Date(displayTime);
      const dayStart = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), 0, 0, 0);
      const dayEnd = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate() + 1, 0, 0, 0); // Midnight of next day
      
      // Check if we need to fetch new data
      // We need new data if:
      // 1. We don't have any data
      // 2. Our current data doesn't cover the full day we're trying to display
      const needNewData = !state.tideData || 
                          state.tideData.length === 0 ||
                          state.tideData[0].time > dayStart ||
                          state.tideData[state.tideData.length - 1].time < dayEnd;
      
      if (needNewData) {
        logger.info('🌊 Fetching new tide data for day:', dayStart.toLocaleDateString());
        state.tideData = await fetchTideData(displayTime);
      }
      
      if (state.tideData) {
        drawTideChart(state.tideData, displayTime);
      }
    }
    
    // ========== MAGNITUDE FUNCTIONS ==========
    
    async function fetchCurrentMagnitude(lat, lon) {
      logger.debug('🎯 fetchCurrentMagnitude called:', { lat, lon });
      
      if (!state.currentModelInfo) {
        logger.warn('❌ No model info available');
        return null;
      }
      
      // Build the time strings for the API
      const cycleStart = new Date(state.currentModelInfo.cycleDate);
      cycleStart.setUTCHours(state.currentModelInfo.cycleHour, 0, 0, 0);
      const startTime = toIsoUTC(cycleStart);
      const endTime = toIsoUTC(state.currentModelInfo.targetTime);
      
      logger.debug('📊 Model info:', {
        cycleStart: formatTimeLocal(cycleStart),
        targetTime: formatTimeLocal(state.currentModelInfo.targetTime),
        startTime,
        endTime
      });
      
      // Call NVS API through proxy to avoid CORS issues
      const layer = `salish-currents-vec/${startTime}/${endTime}/Surface`;
      
      // Always use proxy - NVS doesn't provide CORS headers
      const baseUrl = `${CONFIG.PROXY_HOST}/nvs/get_values`;
      
      const url = `${baseUrl}?` +
        `sid=${Math.random()}&` +
        `layer1=${encodeURIComponent(layer)}&` +
        `var1=H1_CurrSpeed&` +
        `num_layers=1&` +
        `location_mode=interpolate&` +
        `lat=${lat}&` +
        `lon=${lon}`;
      
      logger.debug('🌐 API URL:', url);
      logger.debug('🔀 Using proxy:', baseUrl.includes(CONFIG.PROXY_HOST));
      
      try {
        logger.debug('📡 Fetching from NVS API...');
        const response = await fetch(url);
        logger.debug('📡 Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`API returned ${response.status}`);
        }
        
        const data = await response.json();
        logger.debug('📦 API Response:', data);
        
        if (data.success && data.values && data.values.length > 0) {
          // Convert from m/s to knots (1 m/s = 1.94384 knots)
          const result = {
            value: data.values[0].value * 1.94384,
            direction: data.values[0].direction
          };
          logger.debug('✅ Magnitude data (converted to knots):', result);
          return result;
        } else {
          logger.warn('⚠️ No valid data in response');
        }
      } catch (error) {
        logger.error('❌ Error fetching magnitude:', error);
        return null;
      }
    }
    
    function showMagnitudeMarker(x, y, magnitude, lat, lng) {
      const marker = document.getElementById('magnitude-marker');
      const valueEl = document.getElementById('magnitude-value');
      
      // Format magnitude to 1 decimal place
      valueEl.textContent = magnitude.toFixed(1);
      
      // Position the marker
      marker.style.left = x + 'px';
      marker.style.top = y + 'px';
      marker.style.display = 'block';
      
      // Store marker info including lat/lng for updates
      state.magnitudeMarker = { x, y, magnitude, lat, lng };
    }
    
    function hideMagnitudeMarker() {
      const marker = document.getElementById('magnitude-marker');
      marker.style.display = 'none';
      state.magnitudeMarker = null;
    }
    
    function formatTimeLocal(date) {
      const options = {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      };
      return date.toLocaleString('en-US', options);
    }
    
    function formatTimeShort(date) {
      const options = {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        hour12: true
      };
      return date.toLocaleString('en-US', options);
    }
    
    function showLoading(message = 'Loading...', show = true) {
      const loadingEl = document.getElementById('loading');
      if (show) {
        loadingEl.textContent = message;
        loadingEl.className = 'loading';
      } else {
        loadingEl.className = 'loading hidden';
      }
    }
    
    function showError(message) {
      const loadingEl = document.getElementById('loading');
      loadingEl.innerHTML = `
        <div style="color: #cc0000; font-weight: bold;">⚠️ ${message}</div>
        <button onclick="location.reload()" style="
          margin-top: 10px;
          padding: 8px 16px;
          background: #0066cc;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
        ">Reload App</button>
      `;
      loadingEl.className = 'loading';
    }
    
    function updateTimeDisplay(modelInfo) {
      // Only show forecast time (what time we're showing)
      document.getElementById('forecast-time').textContent = formatTimeLocal(modelInfo.targetTime);
    }
    
    // ========== MAP FUNCTIONS ==========
    
    const map = new maplibregl.Map({
      container: "map",
      style: {
        version: 8,
        sources: {
          basemap: {
            type: "raster",
            tiles: ["https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}"],
            tileSize: 256,
            attribution: "© Esri"
          },
          shoreline: {
            type: "raster",
            tiles: [`${PROXY_BASE}/tiles/us_west_shoreline/v2/ValueLocList/{z}/{y}/{x}.png`],
            tileSize: 256,
            maxzoom: 18
          }
        },
        layers: [
          {
            id: "basemap",
            type: "raster",
            source: "basemap"
          },
          {
            id: "shoreline",
            type: "raster",
            source: "shoreline",
            paint: { "raster-opacity": 1.0 }
          }
        ]
      },
      center: CONFIG.CENTER,
      zoom: CONFIG.ZOOM,
      attributionControl: false // Clean mobile view
    });

// --- Visual viewport sync + MapLibre resize ---
function applyViewportHeight() {
  const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
  document.documentElement.style.setProperty('--vhpx', `${h}px`);
  try { map.resize(); } catch {}
}
window.addEventListener('load', applyViewportHeight);
window.addEventListener('orientationchange', applyViewportHeight);
window.addEventListener('resize', applyViewportHeight);
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', applyViewportHeight);
}

    
    function updateCurrentsLayer(hoursFromNow) {
      // Calculate target time based on hours from current time
      const now = new Date();
      now.setMinutes(0, 0, 0);
      const targetTime = new Date(now.getTime() + hoursFromNow * 60 * 60 * 1000); // Hours into the future
      
      // Find the best model for this target time
      const bestModel = getBestModelForForecast(targetTime);
      
      if (!bestModel) {
        logger.warn('No model available for forecast hour', hoursFromNow);
        return;
      }
      
      // Update current model info
      state.currentModelInfo = bestModel;
      
      // Get the model cycle start time for this specific model
      const thisCycleStart = new Date(bestModel.cycleDate);
      thisCycleStart.setUTCHours(bestModel.cycleHour, 0, 0, 0);
      
      // Update display
      updateTimeDisplay(bestModel);
      
      // Update tide chart for the current display time
      updateTideChart(targetTime);
      
      // Update magnitude marker if one is displayed
      if (state.magnitudeMarker && state.magnitudeMarker.lat && state.magnitudeMarker.lng) {
        // Fetch updated magnitude for the same location
        fetchCurrentMagnitude(state.magnitudeMarker.lat, state.magnitudeMarker.lng).then(result => {
          if (result) {
            // Update just the value, keep the same position
            const valueEl = document.getElementById('magnitude-value');
            if (valueEl) {
              valueEl.textContent = result.value.toFixed(1);
              state.magnitudeMarker.magnitude = result.value;
            }
          }
        });
      }
      
      // CRITICAL: Always use the MODEL CYCLE START as the tile start time
      // The end time determines which forecast hour we get
      const startTime = toIsoUTC(thisCycleStart);
      const endTime = toIsoUTC(targetTime);
      
      const tileUrl = `${PROXY_BASE}/tiles/salish-currents-vec/${startTime}/${endTime}/Surface/v2/ValueLocList/{z}/{y}/{x}.png`;
      
      logger.info(`Target: ${formatTimeLocal(targetTime)} | Model: ${formatTimeLocal(thisCycleStart)} (${bestModel.cycleHour}z) | F${bestModel.forecastHour.toString().padStart(3,'0')}`);
      logger.debug('🗺️ Tile URL pattern:', tileUrl);
      
      if (!map.getSource("currents")) {
        map.addSource("currents", {
          type: "raster",
          tiles: [tileUrl],
          tileSize: 256,
          maxzoom: 18
        });
        map.addLayer({
          id: "currents",
          type: "raster",
          source: "currents",
          paint: { "raster-opacity": 1.0 }
        }, "shoreline");
      } else {
        const source = map.getSource("currents");
        source.tiles = [tileUrl];
        // Clear MapLibre's internal tile cache to force re-fetch
        // (Service worker will still cache the HTTP responses)
        map.style.sourceCaches['currents'].clearTiles();
        map.style.sourceCaches['currents'].update(map.transform);
        map.triggerRepaint();
      }
    }
    
    // ========== MODEL EXPLORATION ==========
    
    // Binary search to find the maximum available forecast hour for a model
    async function findMaxForecastHour(cycleTime) {
      const testStartTime = toIsoUTC(cycleTime);
      let low = 0;
      let high = CONFIG.MAX_FORECAST_HOURS;
      let maxAvailable = -1;
      
      // Helper to test if a specific forecast hour is available
      async function testHour(hour) {
        const endTime = new Date(cycleTime.getTime() + hour * 60 * 60 * 1000);
        const testEndTime = toIsoUTC(endTime);
        const testUrl = `${PROXY_BASE}/tiles/salish-currents-vec/${testStartTime}/${testEndTime}/Surface/v2/ValueLocList/8/90/39.png`;
        
        try {
          const response = await fetch(testUrl);
          if (response.ok) {
            const blob = await response.blob();
            return blob.size >= CONFIG.TILE_MIN_SIZE; // Real data vs placeholder
          }
        } catch (err) {
          // Ignore errors
        }
        return false;
      }
      
      // Binary search for the maximum available hour
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const isAvailable = await testHour(mid);
        
        if (isAvailable) {
          maxAvailable = mid;
          low = mid + 1; // Look for higher hours
        } else {
          high = mid - 1; // Look for lower hours
        }
      }
      
      return maxAvailable;
    }
    
    async function exploreRecentModels(count = 10) {
      logger.info('📊 Exploring recent model cycles (stopping at first full 72h model)...');
      logger.info('================================================');
      
      const now = new Date();
      const results = [];
      let foundFull72 = false;
      
      // Get the latest theoretical cycle
      const latestCycle = getLatestCycle(now);
      let searchDate = new Date(latestCycle.date);
      let cycleIndex = CONFIG.SSCOFS_CYCLES.indexOf(latestCycle.cycle);
      let modelsChecked = 0;
      
      // Check the last N model cycles, but stop once we find a full 72h model
      for (let daysBack = 0; daysBack <= 7 && modelsChecked < count && !foundFull72; daysBack++) {
        for (let i = cycleIndex; i >= 0 && modelsChecked < count && !foundFull72; i--) {
          const testCycle = CONFIG.SSCOFS_CYCLES[i];
          const cycleTime = new Date(searchDate);
          cycleTime.setUTCHours(testCycle, 0, 0, 0);
          
          const hoursOld = (now - cycleTime) / (1000 * 60 * 60);
          
          // Use binary search to find max available forecast hour
          const maxHour = await findMaxForecastHour(cycleTime);
          
          // Calculate the future coverage (hours from now that this model covers)
          const futureStart = Math.max(0, -hoursOld); // When this model starts covering the future
          const futureEnd = maxHour - hoursOld; // How far into the future this model reaches
          
          // Determine status
          let status, details;
          if (maxHour >= 72) {
            status = '✅ FULL';
            details = `F000-F072`;
            foundFull72 = true; // Found a full model, will stop after this
          } else if (maxHour >= 0) {
            status = '⚠️  PARTIAL';
            details = `F000-F${String(maxHour).padStart(3,'0')}`;
          } else {
            status = '❌ NOT FOUND';
            details = '';
          }
          
          // Add future coverage info
          if (futureEnd > 0) {
            details += ` | Future: +${Math.round(futureEnd)}h`;
          } else {
            details += ' | Past only';
          }
          
          logger.info(`${status} | ${formatTimeLocal(cycleTime)} (${String(testCycle).padStart(2,'0')}z) | ${hoursOld.toFixed(1)}h old | ${details}`);
          
          results.push({
            time: cycleTime,
            cycle: testCycle,
            hoursOld: hoursOld,
            maxHour: maxHour,
            futureEnd: futureEnd,
            available: maxHour >= 72,
            partial: maxHour >= 0 && maxHour < 72
          });
          
          modelsChecked++;
          
          if (foundFull72) {
            logger.info('🛑 Stopping exploration - found full 72h model');
          }
        }
        
        searchDate.setUTCDate(searchDate.getUTCDate() - 1);
        cycleIndex = CONFIG.SSCOFS_CYCLES.length - 1;
      }
      
      // Analyze which models are actually needed for future coverage
      logger.info('================================================');
      logger.info('=== Future Coverage Analysis ===');
      
      // Sort by how far into the future they reach
      const futureModels = results
        .filter(r => r.futureEnd > 0)
        .sort((a, b) => b.futureEnd - a.futureEnd);
      
      let maxCoverage = 0;
      const neededModels = [];
      const redundantModels = [];
      
      for (const model of futureModels) {
        if (model.futureEnd > maxCoverage) {
          // This model extends our coverage
          neededModels.push(model);
          logger.info(`✅ NEEDED: ${formatTimeLocal(model.time)} (${model.cycle}z) extends coverage to +${Math.round(model.futureEnd)}h`);
          maxCoverage = model.futureEnd;
        } else {
          // This model is redundant
          redundantModels.push(model);
          logger.info(`⏭️  REDUNDANT: ${formatTimeLocal(model.time)} (${model.cycle}z) only reaches +${Math.round(model.futureEnd)}h`);
        }
      }
      
      // Summary
      logger.info('================================================');
      logger.info(`Models needed for future coverage: ${neededModels.length}`);
      logger.info(`Redundant models: ${redundantModels.length}`);
      logger.info(`Maximum future coverage: +${Math.round(maxCoverage)} hours`);
      
      // Store only the needed models for future coverage
      state.modelAvailability = neededModels;
      
      return results;
    }
    
    // Find the best (newest) model that has data for a specific forecast hour
    function getBestModelForForecast(targetDate) {
      if (!state.modelAvailability || state.modelAvailability.length === 0) {
        return null;
      }
      
      const now = new Date();
      
      // Find the newest model that can provide this forecast
      for (const model of state.modelAvailability) {
        if (model.maxHour < 0) continue; // Skip models with no data
        
        // Calculate what forecast hour this would be for this model
        const modelTime = new Date(model.time);
        const hoursSinceModel = (targetDate - modelTime) / (1000 * 60 * 60);
        
        // Check if this model covers the requested time
        if (hoursSinceModel >= 0 && hoursSinceModel <= model.maxHour) {
          logger.info(`Using model from ${formatTimeLocal(modelTime)} (${model.cycle}z) for F${Math.round(hoursSinceModel).toString().padStart(3,'0')}`);
          return {
            cycleDate: model.time,
            cycleHour: model.cycle,
            forecastHour: Math.round(hoursSinceModel),
            maxHour: model.maxHour,
            targetTime: targetDate
          };
        }
      }
      
      logger.warn('No model available for requested time:', formatTimeLocal(targetDate));
      return null;
    }
    
    // ========== INITIALIZATION ==========
    
    // Monitor online/offline status
    window.addEventListener('online', () => {
      state.isOffline = false;
      logger.info('Back online');
      // Optionally refresh model data
    });
    
    window.addEventListener('offline', () => {
      state.isOffline = true;
      logger.warn('App is offline - using cached data');
      showOfflineIndicator();
    });
    
    function showOfflineIndicator() {
      const indicator = document.createElement('div');
      indicator.id = 'offline-indicator';
      indicator.style.cssText = `
        position: fixed;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        background: #ff9800;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 13px;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      `;
      indicator.textContent = '📵 Offline - Using cached data';
      document.body.appendChild(indicator);
      
      // Remove when back online
      const checkOnline = setInterval(() => {
        if (!state.isOffline) {
          indicator.remove();
          clearInterval(checkOnline);
        }
      }, 1000);
    }
    
    async function initialize() {
      try {
        showLoading('Searching for model data...');
        
        const now = new Date();
        now.setMinutes(0, 0, 0);
        
      logger.info('=== Model Initialization ===');
      logger.info('App Version:', CONFIG.APP_VERSION);
      logger.info('Proxy URL:', CONFIG.PROXY_HOST);
      
      // Display version in UI
      document.getElementById('version-label').textContent = CONFIG.APP_VERSION;
        
        // Check if we're offline
        if (!navigator.onLine) {
          state.isOffline = true;
          logger.warn('Starting in offline mode');
          // Try to use cached model availability from localStorage
          const cachedModels = localStorage.getItem('model_availability');
          if (cachedModels) {
            const parsed = JSON.parse(cachedModels);
            // Convert date strings back to Date objects
            state.modelAvailability = parsed.map(m => ({
              ...m,
              time: new Date(m.time)
            }));
            logger.info('Using cached model availability');
          } else {
            showError('No cached data available. Please connect to internet.');
            return;
          }
        } else {
          // First explore recent models to show what's available
          // This populates the state.modelAvailability array
          await exploreRecentModels(10);
          
          // Cache model availability for offline use
          localStorage.setItem('model_availability', JSON.stringify(state.modelAvailability));
        }
        
        if (!state.modelAvailability || state.modelAvailability.length === 0 || state.modelAvailability.every(m => m.maxHour < 0)) {
          logger.error('❌ No available models found!');
          if (state.isOffline) {
            showError('Cannot load model data while offline.');
          } else {
            showError('No ocean current data available. Please try again later.');
          }
          return;
        }
      
      // Find the maximum future coverage available
      const maxFutureCoverage = Math.max(...state.modelAvailability.map(m => m.futureEnd));
      
      logger.info('=== Model Selection Strategy ===');
      logger.info('Will use the newest model available for each forecast time');
      logger.info(`Future coverage: 0 to +${Math.round(maxFutureCoverage)} hours`);
      
      // Update slider to match available future coverage
      const slider = document.getElementById('time-slider');
      slider.min = 0;
      slider.max = Math.round(maxFutureCoverage);
      slider.value = 0; // Start at current time
      
      // Update slider label
      document.getElementById('slider-label').textContent = `Hours from now (0 to +${Math.round(maxFutureCoverage)})`;
      
      // Update display with initial position (current time)
      updateCurrentsLayer(0);
      
      showLoading('', false);
      } catch (error) {
        logger.error('Initialization error:', error);
        showError('Failed to initialize app. Please check your connection and try again.');
      }
    }
    
    // ========== EVENT HANDLERS ==========
    
    document.getElementById('time-slider').addEventListener('input', (e) => {
      if (state.isUpdating) return;
      
      const hoursFromNow = parseInt(e.target.value);
      
      // Update label to show what time this represents
      const targetTime = new Date();
      targetTime.setMinutes(0, 0, 0);
      targetTime.setHours(targetTime.getHours() + hoursFromNow);
      
      const timeStr = hoursFromNow === 0 ? 'Now' : `+${hoursFromNow}h (${formatTimeShort(targetTime)})`;
      document.getElementById('slider-label').textContent = timeStr;
      
      // Debounce the actual update
      clearTimeout(window.updateTimer);
      window.updateTimer = setTimeout(() => {
        updateCurrentsLayer(hoursFromNow);
      }, 100);
    });
    
    // Hour adjustment buttons
    document.getElementById('hour-prev').addEventListener('click', (e) => {
      const slider = document.getElementById('time-slider');
      const currentValue = parseInt(slider.value);
      const newValue = Math.max(parseInt(slider.min), currentValue - 1);
      slider.value = newValue;
      
      // Trigger the input event
      const event = new Event('input', { bubbles: true });
      slider.dispatchEvent(event);
    });
    
    document.getElementById('hour-next').addEventListener('click', (e) => {
      const slider = document.getElementById('time-slider');
      const currentValue = parseInt(slider.value);
      const newValue = Math.min(parseInt(slider.max), currentValue + 1);
      slider.value = newValue;
      
      // Trigger the input event
      const event = new Event('input', { bubbles: true });
      slider.dispatchEvent(event);
    });
    
    document.getElementById('time-slider').addEventListener('change', (e) => {
      // Reset label after interaction
      const maxHours = parseInt(e.target.max);
      setTimeout(() => {
        document.getElementById('slider-label').textContent = `Hours from now (0 to +${maxHours})`;
      }, 2000);
    });
    
    // ========== TOUCH HANDLERS FOR MAGNITUDE ==========
    
    // Handle tap for showing magnitude
    map.on('click', async (e) => {
      logger.debug('👆 Click/tap event fired', {
        lngLat: e.lngLat,
        point: e.point,
        timestamp: new Date().toISOString()
      });
      
      // Get the click position
      const lngLat = e.lngLat;
      const point = e.point;
      
      // Calculate screen position
      const mapContainer = map.getContainer();
      const rect = mapContainer.getBoundingClientRect();
      const screenPoint = {
        x: point.x + rect.left,
        y: point.y + rect.top
      };
      
      logger.debug('📍 Click position:', {
        screen: screenPoint,
        mapRelative: point,
        lngLat: { lat: lngLat.lat, lng: lngLat.lng }
      });
      
      // Vibrate if available (haptic feedback)
      if (navigator.vibrate) {
        logger.debug('📳 Triggering haptic feedback');
        navigator.vibrate(10);
      }
      
      // Fetch and show magnitude
      logger.debug('🔍 Fetching magnitude for:', { lat: lngLat.lat, lng: lngLat.lng });
      
      // Check if offline
      if (state.isOffline) {
        logger.warn('Cannot fetch magnitude while offline');
        // Could show a message to user
        return;
      }
      
      const result = await fetchCurrentMagnitude(lngLat.lat, lngLat.lng);
      if (result) {
        logger.debug('📌 Showing marker with value:', result.value);
        showMagnitudeMarker(screenPoint.x, screenPoint.y, result.value, lngLat.lat, lngLat.lng);
      } else {
        logger.debug('❌ No result to show');
      }
    });
    
    // Prevent context menu on right-click
    map.on('contextmenu', (e) => {
      e.preventDefault();
    });
    
    // Hide marker when starting to pan
    map.on('movestart', () => {
      logger.debug('🗺️ Map movestart - hiding marker');
      hideMagnitudeMarker();
    });
    
    // Initialize when map loads
    map.on('load', async () => {
      await initialize();
    });
    
    // Handle errors gracefully
    map.on('error', (e) => {
      if (e.error && e.error.status === 404) {
        // Tile not found is common at edges, ignore
      } else if (e.error) {
        logger.error('Map error:', e.error);
      }
    });
    
  </script>
</body>
</html>
